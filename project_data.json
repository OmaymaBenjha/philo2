{
  "Makefile": "NAME = philo\n\nCC = cc\nCFLAGS = -Wall -Wextra -Werror #-g3 -fsanitize=thread\n\nRM = rm -f \n\nSRCS = philo.c \\\n\t   monitor.c \\\n\t   simulation.c \\\n\t   philo_routine.c \\\n\t   stop.c \\\n\t   tools.c \\\n\n\nOBJS = $(SRCS:.c=.o)\n\nall: $(NAME)\n\n$(NAME): $(OBJS)\n\t$(CC) $(OBJS) $(CFLAGS) -o $(NAME)\n\n%.o: %.c\n\t$(CC) $(CFLAGS)  -c $< -o $@\n\nclean:\n\t$(RM) $(OBJS)\n\nfclean: clean\n\t$(RM) $(NAME)\n\nre: fclean all\n\n.PHONY: all clean fclean re\n",
  "monitor.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   monitor.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/16 14:31:35 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/21 19:10:08 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"philo.h\"\n\nstatic void\t*main_loop(t_philosopher *philos, t_simulation *sim)\n{\n\tint\t\ti;\n\tlong\tlast_meal;\n\n\ti = 0;\n\twhile (i < sim->num_of_philo)\n\t{\n\t\tpthread_mutex_lock(&philos[i].meal_mutex);\n\t\tlast_meal = philos[i].last_meal_time;\n\t\t\tpthread_mutex_unlock(&philos[i].meal_mutex);\n\t\tif ((get_time_ms() - last_meal) > sim->time_to_die\n\t\t\t&& !stop_getter(sim))\n\t\t{\n\t\t\tpthread_mutex_lock(&sim->output_mutex);\n            if (!sim->stop)\n            {\n                printf(\"%ld %d died\\n\", get_time_ms() - sim->start_time, philos[i].id);\n\t\t\t\tstop_setter(sim);\n            }\n            pthread_mutex_unlock(&sim->output_mutex);\n            return (NULL);\n\t\t}\n\t\ti++;\n\t}\n\treturn ((void *)1);\n}\n\nstatic void\t*meals_check(t_simulation *sim, t_philosopher *philos)\n{\n\tint\ti;\n\tint\tall_done;\n\n\ti = 0;\n\tall_done = 1;\n\twhile (i < sim->num_of_philo)\n\t{\n\t\tpthread_mutex_lock(&philos[i].meal_mutex);\n\t\tif (philos[i].meals_eaten < sim->must_eat_count && !stop_getter(sim))\n\t\t\tall_done = 0;\n\t\tpthread_mutex_unlock(&philos[i].meal_mutex);\n\t\tif (!all_done)\n\t\t\tbreak ;\n\t\ti++;\n\t}\n\tif (all_done)\n\t{\n\t\tpthread_mutex_lock(&sim->output_mutex);\n\t\tstop_setter(sim);\n\t\tpthread_mutex_unlock(&sim->output_mutex);\n\t\treturn (NULL);\n\t}\n\treturn ((void *)1);\n}\n\nstatic void\t*monitor_routine(void *arg)\n{\n\tt_philosopher\t*philos;\n\tt_simulation\t*sim;\n\n\tphilos = (t_philosopher *)arg;\n\tsim = philos[0].sim;\n\twhile (!stop_getter(sim))\n\t{\n\t\tif (!main_loop(philos, sim))\n\t\t\tbreak ;\n\t\tif (sim->must_eat_count > 0)\n\t\t{\n\t\t\tif (!meals_check(sim, philos))\n\t\t\t\tbreak ;\n\t\t}\n\t\tusleep(1000);\n\t}\n\treturn (NULL);\n}\n\nvoid\tmonitor_trigger(t_simulation *sim)\n{\n\tpthread_t\tmonitor;\n\tint\t\t\ti;\n\n\ti = 0;\n\tpthread_create(&monitor, NULL, monitor_routine, sim->philos);\n\twhile (i < sim->num_of_philo)\n\t{\n\t\tpthread_join(sim->philos[i].thread, NULL);\n\t\ti++;\n\t}\n\tpthread_join(monitor, NULL);\n}\n",
  "philo.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   philo.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/15 20:04:12 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/21 17:28:42 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"philo.h\"\n\nstatic int check_entry(int ac, char **av)\n{\n    if (ac != 5 && ac != 6)\n    {\n        printf(\"Usage: %s num_philos t_die t_eat t_sleep [must_eat]\\n\", av[0]);\n        return (0);\n    }\n    return (1);\n}\nstatic void clean_up(t_simulation *sim)\n{\n    int i;\n    \n    i = 0;\n \n    while (i < sim->num_of_philo)\n    {\n        pthread_mutex_destroy(&sim->forks[i]);\n        i++;\n    }\n    pthread_mutex_destroy(&sim->stop_mutex);\n    pthread_mutex_destroy(&sim->output_mutex);\n    i = 0;\n    while (i < sim->num_of_philo)\n    {\n        pthread_mutex_destroy(&sim->philos[i].meal_mutex);  \n        i++;\n    }\n}\nint main(int ac, char **av)\n{\n    t_simulation    sim;\n\n    if (!check_entry(ac, av))\n        return (0);\n    memset(&sim, 0, sizeof(sim));\n    if (!init_simulation(&sim, ac, av))\n        return(printf(\"Invalid Arguments!\\n\"), 1);\n    init_philo(&sim);\n    simulation_trigger(&sim);\n    monitor_trigger(&sim);\n    clean_up(&sim);\n    return (0);\n}\n",
  "philo.h": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   philo.h                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/15 19:55:11 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/21 16:57:02 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#ifndef PHILO_H\n# define PHILO_H\n# define MAX_PHILO 200\n\n#include <stdlib.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n\nstruct s_simulation;\n\ntypedef struct s_philosopher\n{\n    int                 id;\n    pthread_t           thread;\n    pthread_mutex_t     *l_fork;\n    pthread_mutex_t     *r_fork;\n    long                last_meal_time;\n    int                 meals_eaten;\n    struct s_simulation *sim;\n    pthread_mutex_t     meal_mutex;\n} t_philosopher;\n\ntypedef struct s_simulation\n{\n    int             num_of_philo;\n    long            time_to_die;\n    int             time_to_eat;\n    int             time_to_sleep;\n    int             must_eat_count;\n    int             stop;\n    long            start_time;\n    pthread_mutex_t forks[MAX_PHILO];\n    pthread_mutex_t stop_mutex;\n    pthread_mutex_t output_mutex;\n    t_philosopher   philos[MAX_PHILO];\n} t_simulation;\n\n//-----------------------simulation\nint     init_simulation(t_simulation *sim, int ac, char **av);\nvoid    init_philo(t_simulation *sim);\nvoid    simulation_trigger(t_simulation *sim);\nvoid    *routine(void *data);\nint     stop_getter(t_simulation *sim);\nvoid    stop_setter(t_simulation *sim);\nlong    get_time_ms(void);\nvoid\taccurate_usleep(long time_ms, t_philosopher *p);\nvoid    monitor_trigger(t_simulation *sim);\n\n//-----------------------tools\nvoid\t*ft_memset(void *b, int c, size_t len);\nint\t    ft_atoi(const char *str);\nvoid    print_state(t_philosopher *p, const char *state);\nint     ft_isalpha(const char *av);\n\n\n\n#endif",
  "philo_routine.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   philo_routine.c                                    :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/15 23:22:14 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/21 21:24:39 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"philo.h\"\n\nstatic void locking_mechanism(t_philosopher *p)\n{\n    pthread_mutex_t *first;\n    pthread_mutex_t *second;\n    \n    if (p->id % 2 == 0)\n    {\n        first = p->l_fork;\n        second = p->r_fork;\n    }\n    else\n    {\n        first = p->r_fork;\n        second = p->l_fork;\n    }\n    pthread_mutex_lock(first);\n    print_state(p, \"has taken a fork\");\n    pthread_mutex_lock(second);\n    print_state(p, \"has taken a fork\");\n    print_state(p, \"is eating\");\n    pthread_mutex_lock(&p->meal_mutex);\n    p->last_meal_time = get_time_ms();\n    p->meals_eaten++;\n    pthread_mutex_unlock(&p->meal_mutex);\n    accurate_usleep(p->sim->time_to_eat, p);\n    pthread_mutex_unlock(second);\n    pthread_mutex_unlock(first);    \n}\n\nvoid    *routine(void *data)\n{\n    t_philosopher   *p;\n    \n    p = (t_philosopher *)data;\n    if (p->sim->num_of_philo == 1)\n\t{\n\t\tprint_state(p, \"has taken a fork\");\n\t\taccurate_usleep(p->sim->time_to_die, p);\n\t\treturn (NULL);\n\t}\n    if (p->id % 2 == 0)\n        usleep(500);\n    while (!stop_getter(p->sim))\n    {\n        locking_mechanism(p);\n        if (p->sim->must_eat_count > 0)\n        {\n            pthread_mutex_lock(&p->meal_mutex);\n            if (p->meals_eaten >= p->sim->must_eat_count)\n            {\n                pthread_mutex_unlock(&p->meal_mutex);\n                break ;\n            }\n            pthread_mutex_unlock(&p->meal_mutex);\n        }\n        print_state(p, \"is sleeping\");\n        accurate_usleep(p->sim->time_to_sleep, p);\n        print_state(p, \"is thinking\");\n    }\n    return (NULL);\n}\n",
  "simulation.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   simulation.c                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/15 20:59:13 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/19 14:18:32 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"philo.h\"\n\nint init_simulation(t_simulation *sim, int ac, char **av)\n{\n    int i;\n\n    i = 0;\n    sim->num_of_philo = ft_atoi(av[1]);\n    sim->time_to_die = ft_atoi(av[2]);\n    sim->time_to_eat = ft_atoi(av[3]);\n    sim->time_to_sleep = ft_atoi(av[4]);\n    if (ac == 6)\n        sim->must_eat_count = ft_atoi(av[5]);\n    else\n        sim->must_eat_count = -1;\n    if (sim->num_of_philo <= 0 ||\n        sim->num_of_philo > MAX_PHILO || sim->time_to_die <= 0 ||\n            sim->time_to_eat <= 0 || sim->time_to_sleep <= 0 ||\n                (ac == 6 && sim->must_eat_count <= 0))\n                return (0);\n    pthread_mutex_init(&sim->stop_mutex, NULL);\n    pthread_mutex_init(&sim->output_mutex, NULL);\n    while (i < sim->num_of_philo)\n    {\n        pthread_mutex_init(&sim->forks[i], NULL);\n        i++;\n    }\n    return (1);\n}\nlong get_time_ms(void)\n{\n    struct timeval  tv;\n\n    gettimeofday(&tv, NULL);\n    return ((tv.tv_sec * 1000) + (tv.tv_usec / 1000));\n}\n\nvoid    init_philo(t_simulation *sim)\n{\n    int i;\n\n    i = 0;\n    sim->start_time = get_time_ms();\n    while (i < sim->num_of_philo)\n    {\n        sim->philos[i].id = i + 1;\n        sim->philos[i].sim = sim;\n        sim->philos[i].l_fork = &sim->forks[i];\n        sim->philos[i].r_fork = &sim->forks[(i + 1) % sim->num_of_philo]; \n        pthread_mutex_init(&sim->philos[i].meal_mutex, NULL);          \n        sim->philos[i].last_meal_time = sim->start_time;\n        i++;\n    }\n}\nvoid    simulation_trigger(t_simulation *sim)\n{\n    int i;\n\n    i = 0;\n    while (i < sim->num_of_philo)\n    {\n        pthread_create(&sim->philos[i].thread, NULL, routine, &sim->philos[i]);\n        i++;\n    }\n}\n\n\n\n\n",
  "stop.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   stop.c                                             :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/16 12:29:07 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/20 21:27:34 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"philo.h\"\n\nint stop_getter(t_simulation *sim)\n{\n    int result;\n    \n    pthread_mutex_lock(&sim->stop_mutex);\n    result = sim->stop;\n    pthread_mutex_unlock(&sim->stop_mutex);\n    return (result);\n}\n\nvoid stop_setter(t_simulation *sim)\n{\n    pthread_mutex_lock(&sim->stop_mutex);\n    sim->stop = 1;\n    pthread_mutex_unlock(&sim->stop_mutex);\n}",
  "tools.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   tools.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/15 20:07:20 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/21 19:07:44 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"philo.h\"\n\nvoid\t*ft_memset(void *b, int c, size_t len)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\twhile (i < len)\n\t{\n\t\t((unsigned char *)b)[i] = (unsigned char)c;\n\t\ti++;\n\t}\n\treturn (b);\n}\nint\tft_isalpha(const char *av)\n{\n\tint\ti;\n\t\n\ti = 0;\n\twhile (av[i])\n\t{\n\t\tif (!(av[i] >= '0' && av[i] <= '9'))\n\t\t\treturn (0);\n\t\ti++;\n \t}\n\treturn (1);\n}\n\nint\tft_atoi(const char *str)\n{\n\tint\t\ti;\n\tint\t\tsign;\n\tlong\tresult;\n\n\ti = 0;\n\tsign = 1;\n\tresult = 0;\n\twhile (str[i] == ' ' || (str[i] >= '\\t' && str[i] <= '\\r'))\n\t\ti++;\n\tif (str[i] == '-' || str[i] == '+')\n\t{\n\t\tif (str[i] == '-')\n\t\t\tsign = -1;\n\t\ti++;\n\t}\n\tif (!ft_isalpha(&str[i]))\n\t\treturn (0);\n\twhile (str[i] >= '0' && str[i] <= '9')\n\t{\n\t\tif ((result > INT_MAX / 10)\n\t\t\t|| (result == INT_MAX / 10 && (str[i] - '0') > INT_MAX % 10))\n\t\t\treturn (-1);\n\t\tresult = result * 10 + (str[i] - '0');\n\t\ti++;\n\t}\n\treturn ((int)(result * sign));\n}\nvoid\taccurate_usleep(long time_ms, t_philosopher *p)\n{\n\tlong\tstart;\n\n\tstart = get_time_ms();\n\twhile (get_time_ms() - start < time_ms)\n\t{\n\t\tif(stop_getter(p->sim))\n\t\t\tbreak ;\n\t\tusleep(500);\n\t}\n\t\t\n}\nvoid print_state(t_philosopher *p, const char *state)\n{\n\tlong\ttstp;\n\n    pthread_mutex_lock(&p->sim->output_mutex);\n    if (!stop_getter(p->sim))\n\t{\n\t\tif (stop_getter(p->sim))\n            return ;\n\t\ttstp = get_time_ms() - p->sim->start_time;\n\t\tprintf(\"%ld %d %s\\n\", tstp, p->id, state);\n\t}\n    pthread_mutex_unlock(&p->sim->output_mutex);\n}\n"
}